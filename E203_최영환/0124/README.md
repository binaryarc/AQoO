# 01/24

# OAuth(구글, 카카오 구현)

어제에 이어서 구글, 카카오 로그인을 구현하려고 하다보니 구글의 경우는 Spring Security에서 자동으로 Provider를 처리하기 때문에 application.yml 에 명시적으로 경로가 나타나있지 않아서 리다이렉트된 것을 어떻게 처리해주어야 할지 의문이 들었다.

그래서 곰곰이 생각해보니 Spring Security에서 자동으로 처리해주는 이유가 뭔지 알게되고, 리다이렉트 된 것도 자동으로 처리해준다는 것도 알게 되었다.

그렇다면 네이버 구현할 때 자동으로 경로를 가로챈 이유가 이것을 자동으로 처리해주기 때문이라는 것을 알았고, 이것들을 spring security가 전부 알아서 처리해준다면 개발자 입장에서는 application.yml에 기업 이름과 각 기업에 따라 어느 uri를 보낼지만 간단하게 알려주면 알아서 다 처리해주는 것을 알게 되었다.

(만약 명시적으로 전부 내가 처리하려면 모든 컨트롤러, 서비스를 구현해야 해서 코드가 길어지고 개발 시간도 길어질 것)

만약 추가적으로 API를 요청해서 해당 기업의 데이터를 변경한다던지 특정한 로직을 수행할 필요가 있다면 Service에서 추가적으로 로직을 구현하고, Spring Security에서 자동으로 처리하지 않도록 해주면 되고, 그런 게 아니라면 Security에서 자동으로 처리하도록 하는 것이 편하단 것을 알게 되었다.

→ Spring Security에서 자꾸 가로챘던 이유는 Spring Security에서 내가 하고자 했던 기능들을 다 처리할 수 있기 때문이었다.

### 요약

사용자가 로그인 정보를 입력하여 로그인하기 버튼을 누르면 Spring Security에서는 리다이렉트 된 정보(임시 인증 정보)를 가지고 알아서 다시 기업에게 AccessToken을 요청하여 내부적으로 저장해놓고 기본적으로 보내달라고 해놨던 정보들을 받아서 저장해놓고 사용한다. (Principal 객체에 저장)

만약 이 정보를 개발자가 꺼내서 쓰고 싶다면 컨트롤러에서 `@AuthenticationPrincipal` 로 객체에서 꺼내서 쓰면 된다.

### 발생한 문제점 및 해결

근데 이렇게 하니 네이버 로그인 시에 사용자 정보를 제대로 받아오지 않는 문제가 생겼다.

네이버의 경우는 API 응답을 JSON에 담아줄 때 

```json
{
    "resultcode": "00",
    "message": "success",
    "response": {
        "id": "unique-id",
        "email": "user@example.com",
        "name": "홍길동"
    }
}
```

형태로 담아오는데, 이때 email, name정보가 response 객체에 담겨오기 때문에 Spring Security에서 자동으로 처리해주지 못하는 것이었다. 따라서 응답으로 온 정보가 oAuth2User에 담겨있는데, 이 내부 정보 중 response 객체만 따로 빼서 다시 oAuth2User로 갱신해줘야 했다.

이렇게 하기 위해서 Spring Security가 AccessToken으로 사용자 정보를 요청할 때 사용자 정보를 커스텀 하는 추가적인 로직이 필요했고 (네이버 json 데이터에서 response 객체만 oAuth2User 객체에 담아주는 로직) Spring Security에 코드를 추가하여 (`userInfoEndpoint.userService()`) 사용자 정보 요청 시에 해당 서비스 로직을 수행하도록 코드를 구현했다.

카카오 로그인의 경우 카카오는 비즈니스 등록을 하지 않으면 이메일을 반환해주지 않는 점.

그리고 AccessToken 요청을 Spring Security가 자동으로 처리하는 `client_secret_basic`방식이 아닌 인증 정보를 POST 본문에 포함시키는 방식을 사용한다는 점

이 두 가지 이유 때문에 카카오는 넣지 않기로 함.

갑자기 카카오는 왜 일반적인 표준 OAuth2의 방식을 따르지 않는지 궁금해 찾아봄

### **1. 카카오가 표준을 준수하지 않은 이유**

### **(1) 독자적인 인증 설계**

- 카카오는 대한민국에서 독자적인 사용자 인증 및 데이터 API 생태계를 구축하면서, OAuth2를 기본으로 하지만 자체 요구사항에 맞춘 방식을 설계했습니다.
- **OAuth2 표준의 유연성**을 활용하여 일부 과정을 커스터마이징한 것으로 볼 수 있습니다.

### **(2) 간소화된 클라이언트 인증 방식**

- 표준 OAuth2는 클라이언트 인증에 **client_secret_basic** 방식을 주로 사용하며, 이는 헤더에서 `Authorization: Basic {Base64(client_id:client_secret)}` 형태로 인증 정보를 전달합니다.
- 그러나 카카오는 간소화를 위해 클라이언트 인증 정보를 **HTTP POST 본문**에 포함하도록 설계했습니다. 이는:
    - 헤더 기반 인증보다 구현이 단순하고,
    - 개발자가 쉽게 클라이언트를 통합할 수 있도록 설계된 결정일 수 있습니다.
    - 하지만 이는 엄밀히 말해 표준 방식과 다릅니다.

### **(3) 국내 사용자 기반 고려**

- 카카오는 대한민국에서 주로 사용되며, OAuth2 표준 준수보다는 **국내 사용자 및 개발자 경험 최적화**에 중점을 둔 것으로 보입니다.
- 특히, 국내에서는 OAuth2 인증 과정이 비교적 간단한 예제로 많이 사용되기 때문에, 개발자가 쉽게 이해하고 구현할 수 있는 방식으로 설계했을 가능성이 높습니다.

---

### **2. 카카오의 인증 방식이 표준에서 벗어난 부분**

### **(1) 클라이언트 인증 방식**

- 표준 OAuth2:
    - `client_id`와 `client_secret`을 헤더(`Authorization`)에 전달하는 방식이 일반적입니다.
    - `client_secret_basic` 또는 `client_secret_post` 방식을 선택적으로 지원.
- 카카오:
    - `client_secret_basic` 방식을 지원하지 않으며, 인증 정보를 POST 본문에 포함시키는 방식을 사용합니다.

### **(2) 사용자 정보 구조**

- 카카오는 사용자 정보를 제공할 때 표준 JSON 구조를 따르지 않고, 독자적인 JSON 구조를 사용합니다.
    - 예: `properties`와 `kakao_account`로 나뉘어 있는 응답 구조.

---

### **3. 표준 준수를 강제하지 않은 이유**

OAuth2는 프로토콜로서 유연성을 제공하므로, 서비스 제공자는 필요에 따라 일부를 수정하여 사용할 수 있습니다. 카카오가 표준을 일부 벗어난 방식으로 동작하는 이유는:

- **서비스 차별화**: 독자적인 구조와 방식으로 자신만의 인증 및 API 환경을 구축.
- **사용자 편의성**: 간소화된 인증 절차와 데이터 구조를 제공하여 국내 개발자들이 쉽게 통합할 수 있도록 설계.
- **시장 요구 반영**: 국내 환경에 맞춘 방식으로 설계하여, 글로벌 표준 준수보다는 실제 사용성을 우선.

---

### **4. 결론**

카카오는 OAuth2 표준을 크게 벗어나지 않았지만, 일부 구현에서 독자적인 방식(POST 본문에 클라이언트 인증 정보 포함 등)을 선택했습니다. 이는 서비스 차별화와 개발자 편의성, 시장 요구에 맞춘 결과입니다.

# EC2

### UFW

- 리눅스 환경에서 작동되는 방화벽
- SSH(22), HTTP(80), HTTPS(443) 포트는 열어둬야 한다!

### SSH

- 원격 서버와 통신하기 위한 프로토콜
- 리눅스 명령어로 원격 서버를 제어
- pem키 : SSH 접속 시 사용하는 열쇠
- 깃, 클라우드 스토리지에 함부로 올리면 안됨!(비용 엄청나게 나옴)

# CI / CD

지속적 통합/지속적 배포

# Jenkins

잰킨스 : 빌드 테스트 배포 등 개발 과정을 자동화

# Docker

- Dockerfile : 도커 이미지를 생성하기 위한 스크립트
- Docker Image : 컨테이너 실행에 필요한 모든 정보를
- docker hub : 다른 사람이 올린 이미지를 받거나 나의 이미지를 공유 가능
- Docker Container : 애플리케이션 실행을 위한 모든 것을 포함한 SW 패키지

### 명령어

- docker run [옵션] 이미지명 : 컨테이너 실행하기
- docker ps [옵션] : 실행 중인 컨테이너 목록 확인
- docker stop 컨테이너 ID : 컨테이너 중지
- docker rm 컨테이너 ID : 컨테이너 삭제
- docker images : 저장된 이미지 확인
- docker logs -f <컨테이너 앞 3자리> : 컨테이너 로그 확인

EC2 사용

mobaxterm 실행 → Session버튼 클릭 → SSH → host: @뒷부분 → username : ubuntu → SSH settings에서 pem키 업로드