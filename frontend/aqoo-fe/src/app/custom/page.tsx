"use client";

import { useEffect, useRef, useState } from "react";

import Image from "next/image";
import MenuButton from "../main/MenuButton";
import axios from "axios";
import { useAuth } from "@/hooks/useAuth";
import { useRouter } from "next/navigation";

export default function CustomFishPages() {
  const router = useRouter();
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const contextRef = useRef<CanvasRenderingContext2D | null>(null);

  const [lineMode, setLineMode] = useState(true); // Line Î™®Îìú Ïó¨Î∂Ä

  const [isDrawing, setIsDrawing] = useState(false);
  const [penColor, setPenColor] = useState("black");
  const [penWidth, setPenWidth] = useState(20);
  const [eraserMode, setEraserMode] = useState(false);
  const [fillMode, setFillMode] = useState(false);
  const [history, setHistory] = useState<string[]>([]);
  const [redoStack, setRedoStack] = useState<string[]>([]);
  const [background, setBackground] = useState("/background-1.png");
  const [fishName, setFishName] = useState(""); // üé® Î¨ºÍ≥†Í∏∞ Ïù¥Î¶Ñ

  const { auth } = useAuth();
  const userId = auth.user?.id;

  useEffect(() => {
    const savedBg = localStorage.getItem("background");
    if (savedBg) setBackground(savedBg);

    const canvas = canvasRef.current;
    if (!canvas) return;

    const context = canvas.getContext("2d");
    if (!context) return;

    context.lineCap = "round";
    context.lineWidth = penWidth;
    contextRef.current = context;

    // üåü Î¶¨ÏÇ¨Ïù¥Ïßï Ïãú Í∏∞Ï°¥ Í∑∏Î¶º Ï†ÄÏû• ÌõÑ Î≥µÏõêÌïòÎäî Ìï®Ïàò
    const updateCanvasSize = () => {
      const canvas = canvasRef.current;
      if (!canvas || !contextRef.current) return;

      const context = contextRef.current;

      // üåü Í∏∞Ï°¥ Í∑∏Î¶º Ï†ÄÏû•
      const prevCanvasData = canvas.toDataURL();

      const parent = canvas.parentElement;
      if (!parent) return;

      const newWidth = parent.clientWidth * 0.9; // Î∂ÄÎ™® ÏöîÏÜå Í∏∞Ï§Ä ÌÅ¨Í∏∞ Ï°∞Ï†ï
      const newHeight = (newWidth * 3) / 4; // 4:3 ÎπÑÏú® Ïú†ÏßÄ

      // üåü Í∏∞Ï°¥ Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ï†ÑÏóê ÌòÑÏû¨ Í∑∏Î¶¨Í∏∞ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setIsDrawing(false);

      canvas.width = newWidth;
      canvas.height = newHeight;

      // üåü Í∏∞Ï°¥ Í∑∏Î¶º Î≥µÏõê
      const img = new window.Image();
      img.src = prevCanvasData;
      img.onload = () => {
        context.drawImage(img, 0, 0, newWidth, newHeight);

        // ‚úÖ Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω ÌõÑ `penWidth`Î•º Îã§Ïãú Ï†ÅÏö©ÌïòÏó¨ ÎèôÍ∏∞Ìôî
        context.lineCap = "round";
        context.lineWidth = penWidth; // üëà Ïó¨Í∏∞ÏÑú `penWidth`Î•º Í∞ïÏ†úÎ°ú Ï†ÅÏö©
        context.strokeStyle = eraserMode ? "white" : penColor;
      };
    };

    // üåü Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†ï Î∞è Ï¥àÍ∏∞ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
    updateCanvasSize();
    saveToHistory();

    // üåü Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Í∞êÏßÄ ‚Üí Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏
    window.addEventListener("resize", updateCanvasSize);
    return () => window.removeEventListener("resize", updateCanvasSize);
  }, []);

  // Ìéú ÍµµÍ∏∞ Î≥ÄÍ≤Ω Ïãú `context.lineWidth` ÏóÖÎç∞Ïù¥Ìä∏ (Ï∫îÎ≤ÑÏä§Î•º Îã§Ïãú Í∑∏Î¶¨ÏßÄ ÏïäÏùå)
  useEffect(() => {
    if (contextRef.current) {
      contextRef.current.lineWidth = penWidth;
    }
  }, [penWidth]); // ‚úÖ Ìéú ÍµµÍ∏∞ Î≥ÄÍ≤Ω ÏãúÏóêÎßå Ïã§ÌñâÎê® (Î¶¨ÏÇ¨Ïù¥ÏßïÍ≥º Î∂ÑÎ¶¨)

  const getCanvasCoordinates = (event: React.MouseEvent) => {
    if (!canvasRef.current) return { x: 0, y: 0 };

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect(); // Ï∫îÎ≤ÑÏä§Ïùò ÏúÑÏπò Î∞è ÌÅ¨Í∏∞ Í∞ÄÏ†∏Ïò§Í∏∞

    // ÎπÑÏú® Ï°∞Ï†ï (CSS ÌÅ¨Í∏∞ÏôÄ Ïã§Ï†ú Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï∞®Ïù¥ Î≥¥Ï†ï)
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
      x: (event.clientX - rect.left) * scaleX,
      y: (event.clientY - rect.top) * scaleY,
    };
  };

  const saveToHistory = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const dataURL = canvas.toDataURL();
    setHistory((prev) => [...prev, dataURL]);
  };

  const undo = () => {
    if (history.length <= 1) return;
    const newHistory = [...history];
    const lastState = newHistory.pop();
    if (!lastState) return; // üö® ÎßàÏßÄÎßâ ÏÉÅÌÉúÍ∞Ä undefinedÏù¥Î©¥ return

    setRedoStack((prev) => [...prev, lastState]);
    setHistory(newHistory);
    if (newHistory.length > 0) restoreCanvas(newHistory[newHistory.length - 1]);
  };

  const redo = () => {
    if (redoStack.length === 0) return;
    const redoState = redoStack.pop();
    if (!redoState) return; // üö® redoStateÍ∞Ä undefinedÏùº Îïå return

    setHistory((prev) => [...prev, redoState]);
    restoreCanvas(redoState);
  };

  const restoreCanvas = (dataURL: string) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const context = canvas.getContext("2d");
    if (!context) return;

    const img = new window.Image(); // ‚¨ÖÔ∏è `window.Image`Î°ú Î™ÖÌôïÌûà ÏßÄÏ†ïÌïòÏó¨ Ï∂©Îèå Î∞©ÏßÄ
    img.src = dataURL;
    img.onload = () => {
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(img, 0, 0);
    };
  };

  const startDrawing = (event: React.MouseEvent) => {
    if (fillMode) {
      const { x, y } = getCanvasCoordinates(event);
      fillArea(x, y);
      return;
    }

    if (!contextRef.current) return;
    setIsDrawing(true);

    const context = contextRef.current;
    const { x, y } = getCanvasCoordinates(event); // Ï†ïÌôïÌïú Ï¢åÌëú Í∞ÄÏ†∏Ïò§Í∏∞
    context.beginPath();
    context.moveTo(x, y);
    context.strokeStyle = eraserMode ? "white" : penColor;
  };

  const draw = (event: React.MouseEvent) => {
    if (!isDrawing || !contextRef.current) return;
    const context = contextRef.current;
    const { x, y } = getCanvasCoordinates(event); // ÏàòÏ†ïÎêú Ï¢åÌëú ÏÇ¨Ïö©
    context.lineTo(x, y);
    context.stroke();
  };

  const stopDrawing = () => {
    if (!isDrawing) return;
    setIsDrawing(false);
    if (contextRef.current) {
      contextRef.current.closePath();
    }
    saveToHistory(); // Ïù¥ Ìï®ÏàòÏóêÏÑú redoStack Ï¥àÍ∏∞Ìôî X
  };

  const clearCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas || !contextRef.current) return;
    contextRef.current.clearRect(0, 0, canvas.width, canvas.height);
    saveToHistory();
  };

  // ÏÉâ Ï±ÑÏö∞Í∏∞ Ìï®Ïàò ÏãúÏûë
  const fillArea = (x: number, y: number) => {
    const canvas = canvasRef.current;
    if (!canvas || !contextRef.current) return;

    const context = contextRef.current;
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Ï¢åÌëúÎ•º Ï†ïÏàòÎ°ú Î≥ÄÌôò (Ïò§Ï∞® Î∞©ÏßÄ)
    const startX = Math.floor(x);
    const startY = Math.floor(y);

    const targetColor = getColorAtPixel(data, startX, startY, canvas.width);
    const fillColor = hexToRGBA(penColor);

    if (colorsMatch(targetColor, fillColor)) return; // Í∞ôÏùÄ ÏÉâÏù¥Î©¥ Ï±ÑÏö∞ÏßÄ ÏïäÏùå

    floodFill(data, startX, startY, canvas.width, canvas.height, targetColor, fillColor);

    context.putImageData(imageData, 0, 0);
    saveToHistory();
  };

  const getColorAtPixel = (data: Uint8ClampedArray, x: number, y: number, width: number) => {
    const index = (y * width + x) * 4;
    return [data[index], data[index + 1], data[index + 2], data[index + 3]];
  };

  const hexToRGBA = (hex: string) => {
    const bigint = parseInt(hex.slice(1), 16);
    return [
      (bigint >> 16) & 255, // Red
      (bigint >> 8) & 255, // Green
      bigint & 255, // Blue
      255, // Alpha (fully opaque)
    ];
  };

  // ÏÉâ ÎπÑÍµêÌï† Îïå tolerance(ÌóàÏö© Ïò§Ï∞®) Ï∂îÍ∞Ä
  const colorsMatch = (a: number[], b: number[], tolerance = 10) => {
    return (
      Math.abs(a[0] - b[0]) <= tolerance &&
      Math.abs(a[1] - b[1]) <= tolerance &&
      Math.abs(a[2] - b[2]) <= tolerance &&
      Math.abs(a[3] - b[3]) <= tolerance
    );
  };

  // flood fill ÏïåÍ≥†Î¶¨Ï¶ò ÏµúÏ†ÅÌôî (visited Î∞∞Ïó¥ Ï∂îÍ∞Ä)
  const floodFill = (
    data: Uint8ClampedArray,
    x: number,
    y: number,
    width: number,
    height: number,
    targetColor: number[],
    fillColor: number[]
  ) => {
    const stack = [[x, y]];
    const visited = new Set(); // Î∞©Î¨∏Ìïú Ï¢åÌëú Ï†ÄÏû• (Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ)

    const pixelMatches = (x: number, y: number) => {
      const index = (y * width + x) * 4;
      return colorsMatch(targetColor, [data[index], data[index + 1], data[index + 2], data[index + 3]]);
    };

    const setColor = (x: number, y: number) => {
      const index = (y * width + x) * 4;
      data[index] = fillColor[0];
      data[index + 1] = fillColor[1];
      data[index + 2] = fillColor[2];
      data[index + 3] = fillColor[3];
    };

    while (stack.length) {
      const [px, py] = stack.pop()!;
      const key = `${px},${py}`;

      if (visited.has(key)) continue; // Ïù¥ÎØ∏ Î∞©Î¨∏Ìïú ÌîΩÏÖÄÏù¥Î©¥ Í±¥ÎÑàÎúÄ
      visited.add(key);

      if (px < 0 || py < 0 || px >= width || py >= height || !pixelMatches(px, py)) continue;

      setColor(px, py);

      stack.push([px + 1, py], [px - 1, py], [px, py + 1], [px, py - 1]);
    }
  };

  // ÏÉâ Ï±ÑÏö∞Í∏∞ Ìï®Ïàò ÎÅù

  // ‚úÖ API ÏöîÏ≤≠ÏùÑ ÏúÑÌïú `handleSaveDrawing` Ìï®Ïàò
  const handleSaveDrawing = async () => {
    if (!fishName.trim()) {
      alert("Î¨ºÍ≥†Í∏∞ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!");
      return;
    }

    const canvas = canvasRef.current;
    if (!canvas) return;

    // ‚úÖ 1. Ï∫îÎ≤ÑÏä§Î•º Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò (Blob)
    canvas.toBlob(async (blob) => {
      if (!blob) return;

      const formData = new FormData();
      formData.append(
        "fishData",
        JSON.stringify({
          userId: userId,
          fishName: fishName,
        })
      );
      formData.append("image", blob, `${fishName}.png`);

      try {
        // ‚úÖ 2. API Ìò∏Ï∂ú (multipart/form-data)
        const response = await axios.post("/api/v1/fish/painting", formData, {
          headers: { "Content-Type": "multipart/form-data" },
        });

        console.log("‚úÖ ÏÑ±Í≥µ:", response.data);
        alert("Í∑∏Î¶ºÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!");
        router.push("/somewhere"); // ‚úÖ Ï†ÄÏû• ÌõÑ Î¶¨ÎîîÎ†âÏÖòÌï† ÌéòÏù¥ÏßÄ
      } catch (error) {
        console.error("üö® Ïò§Î•ò:", error);
        alert("Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
      }
    }, "image/png");
  };

  return (
    <div className="relative w-full min-h-screen flex items-center justify-center px-4">
      <title>AQoO</title>

      {/* üñº Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ */}
      <div
        className="absolute inset-0 bg-cover bg-center w-full h-full before:absolute before:inset-0 before:bg-white/30"
        style={{ backgroundImage: `url(${background})` }}
      ></div>

      {/* üñº Î©îÏù∏ Ïª®ÌÖåÏù¥ÎÑà */}
      <div className="relative flex flex-col items-center bg-white border-[2px] mt-10 border-black rounded-lg p-6 w-full max-w-4xl text-center shadow-lg">
        {/* üé® ÌÉÄÏù¥ÌãÄ */}
        <div className="absolute -top-10 left-1/2 -translate-x-1/2 min-w-[300px] sm:min-w-[420px] flex items-center justify-center text-center px-6 py-2 bg-white border-[2px] border-black rounded-md shadow-md">
          <Image src="/icon/paintIcon.png" alt="paint" width={32} height={32} className="mr-2" />
          <h2 className="text-2xl sm:text-4xl font-bold tracking-widest text-black mx-4">Î¨ºÍ≥†Í∏∞ Í∑∏Î¶¨Í∏∞</h2>
          <Image src="/icon/paintIcon.png" alt="paint" width={32} height={32} className="ml-2 scale-x-[-1]" />
        </div>

        {/* üé® Ï∫îÎ≤ÑÏä§ ÏòÅÏó≠ */}
        <div className="flex flex-col md:flex-row w-full  items-center justify-center">
          {/* üé® ÏÉâÏÉÅ ÌåîÎ†àÌä∏ */}
          <div className="grid grid-cols-5 md:flex md:flex-col gap-2 p-2">
            {["#FF0000", "#FFA500", "#FFFF00", "#008000", "#0000FF", "#800080", "#FFC0CB", "#000000", "#FFFFFF"].map(
              (color) => (
                <button
                  key={color}
                  onClick={() => setPenColor(color)}
                  className={`w-8 h-8 sm:w-10 sm:h-10 border border-black rounded-md 
          ${penColor === color ? "border-8 border-black" : "border"}`}
                  style={{ backgroundColor: color }}
                />
              )
            )}
          </div>

          {/* üñº Ï∫îÎ≤ÑÏä§ */}
          <canvas
            ref={canvasRef}
            style={{ border: "1px solid black", cursor: fillMode ? "pointer" : "crosshair" }}
            onMouseDown={startDrawing}
            onMouseMove={draw}
            onMouseUp={stopDrawing}
            onMouseLeave={stopDrawing}
            className="border-[3px] border-black bg-white w-full max-w-[600px] h-[300px] sm:h-[400px]"
          />

          {/* üé® ÎèÑÍµ¨ Î©îÎâ¥ */}
          <div className="grid grid-cols-3 md:flex md:flex-col gap-4 ml-4">
            {/* ‚úèÔ∏è Ìéú ÍµµÍ∏∞ Ï°∞Ï†à Ïä¨ÎùºÏù¥Îçî */}
            <div className="flex flex-col items-center">
              <span className="text-xs">{penWidth}px</span>
              <input
                type="range"
                min="10"
                max="30"
                value={penWidth}
                onChange={(e) => {
                  const newWidth = Number(e.target.value);
                  setPenWidth(newWidth);
                  if (contextRef.current) contextRef.current.lineWidth = newWidth;
                }} // ‚úÖ Ïó¨Í∏∞ÏÑú Ï∫îÎ≤ÑÏä§Î•º Îã§Ïãú Í∑∏Î¶¨ÏßÄ ÏïäÏùå
                className="w-16 mt-2"
              />
            </div>

            <MenuButton
              icon="/icon/drawtool/lineIcon.png"
              label="Line"
              onClick={() => {
                setLineMode(!lineMode);
                setEraserMode(false);
                setFillMode(false);
              }}
              className={`${lineMode ? "bg-gray-300" : "bg-white"} !w-14 !h-14`}
            />

            <MenuButton
              icon="/icon/drawtool/eraserIcon.png"
              label="Eraser"
              onClick={() => {
                setEraserMode(!eraserMode);
                setFillMode(false);
                setLineMode(false);
              }}
              className={`${eraserMode ? "bg-gray-300" : "bg-white"}  !w-14 !h-14`}
            />
            <MenuButton
              icon="/icon/drawtool/fillIcon.png"
              label="Fill"
              onClick={() => {
                setFillMode(!fillMode);
                setEraserMode(false);
                setLineMode(false);
              }}
              className={`${fillMode ? "bg-gray-300" : "bg-white"}  !w-14 !h-14`}
            />
            <MenuButton
              icon="/icon/drawtool/clearIcon.png"
              label="Clear"
              onClick={clearCanvas}
              className={"!w-14 !h-14"}
            />
            <MenuButton icon="/icon/drawtool/undoIcon.png" label="Undo" onClick={undo} className={"!w-14 !h-14"} />
            <MenuButton icon="/icon/drawtool/redoIcon.png" label="Redo" onClick={redo} className={"!w-14 !h-14"} />
          </div>
        </div>

        {/* ‚úÖ üêü Î¨ºÍ≥†Í∏∞ Ïù¥Î¶Ñ ÏûÖÎ†• */}
        <input
          type="text"
          placeholder="Î¨ºÍ≥†Í∏∞ Ïù¥Î¶Ñ ÏûÖÎ†•"
          value={fishName}
          onChange={(e) => setFishName(e.target.value)}
          className="px-4 py-2 border border-gray-300 rounded-md text-lg w-full sm:w-96 text-center"
        />

        {/* üèÅ Î≤ÑÌäº */}
        <div className="flex flex-col items-center justify-center sm:flex-row gap-4 mt-6 w-full">
          <button
            onClick={() => router.back()}
            className="px-6 py-3 bg-gray-400 text-white rounded-lg shadow-md w-full sm:w-auto"
          >
            Ï∑®ÏÜåÌïòÍ∏∞
          </button>
          <button
            onClick={handleSaveDrawing}
            className="px-6 py-3 bg-blue-500 text-white rounded-lg shadow-md w-full sm:w-auto"
          >
            Í∑∏Î¶¨Í∏∞ ÏôÑÎ£å
          </button>
        </div>
      </div>
    </div>
  );
}
